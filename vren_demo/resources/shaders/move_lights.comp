#version 460

#define PI  3.14
#define EPS 0.001
#define INF 1e35

#define MAX_ITERS 256

#define VREN_MAX_POINT_LIGHTS 1024

layout (local_size_x = 512, local_size_y = 1, local_size_z = 1) in;

/* */

layout(push_constant) uniform PushConstants
{
    vec3 scene_min; float _pad;
    vec3 scene_max; float _pad1;
    float speed;
    float dt;
    float _pad2[2];
} push_constants;

// TODO dt ?

/* */

struct PointLight
{
    vec3 pos; float _pad;
    vec3 col; float _pad1;
};

struct DirLight
{
    vec3 dir; float _pad;
    vec3 col; float _pad1;
};

struct SpotLight
{
    vec3 dir; float _pad;
    vec3 col; float _pad1;
    float r;  float _pad2[3];
};

layout(set = 0, binding = 0) buffer LightArray_PointLights
{
    uint num; float _pad[3];
    PointLight buf[];
} b_point_lights;

layout(set = 0, binding = 1) buffer LightArray_DirLights
{
    uint num; float _pad[3];
    DirLight buf[];
} b_dir_lights;

layout(set = 0, binding = 2) buffer LightArray_SpotLights
{
    uint num; float _pad[3];
    SpotLight buf[];
} b_spot_lights;

/* */

layout(set = 1, binding = 0) buffer LightArrayMovementBuf
{
    vec4 buf[VREN_MAX_POINT_LIGHTS];
} b_point_lights_dirs;

/* */

void main()
{
    uint idx = gl_GlobalInvocationID.x;

    if (idx >= b_point_lights.num) {
        return;
    }

    vec3 sM = push_constants.scene_max;
    vec3 sm = push_constants.scene_min;

    vec3 p = b_point_lights.buf[idx].pos;
    p = (sM + sm) / 2.;// TODO min(max(p, sm), sM); // Brings the light position within the scene's AABB.

    vec3 d = b_point_lights_dirs.buf[idx].xyz;

    // We need to go forward by `speed`, but we can't go straight, we have to consume this value over the bouncings.
    float rem_t = push_constants.speed * push_constants.dt;

    for (int i = 0; i < MAX_ITERS && rem_t > 0; i++)
    {
        // Gets the distance to all the walls of the AABB, if the wall is behind, then sets it to INF.
        float tx1 = (sm.x - p.x) / d.x; tx1 = tx1 <= 0 ? INF : tx1;
        float tx2 = (sM.x - p.x) / d.x; tx2 = tx2 <= 0 ? INF : tx2;
        float ty1 = (sm.y - p.y) / d.y; ty1 = ty1 <= 0 ? INF : ty1;
        float ty2 = (sM.y - p.y) / d.y; ty2 = ty2 <= 0 ? INF : ty2;
        float tz1 = (sm.z - p.z) / d.z; tz1 = tz1 <= 0 ? INF : tz1;
        float tz2 = (sM.z - p.z) / d.z; tz2 = tz2 <= 0 ? INF : tz2;

        // Gets the distance from the nearest wall (beyond walls will be excluded because their distance is set to INF).
        float min_t = min(tx1, min(tx2, min(ty1, min(ty2, min(tz1, tz2)))));

        float dt = min(min_t - EPS, rem_t); // How much we can step forward.
        p += dt * d;

        // If we hit a wall, we need to reverse the ray direction accordingly.
        if (min_t < rem_t)
        {
            d *= vec3(
                (tx1 == min_t || tx2 == min_t ? -1.0 : 1.0),
                (ty1 == min_t || ty2 == min_t ? -1.0 : 1.0),
                (tz1 == min_t || tz2 == min_t ? -1.0 : 1.0)
            );
        }

        rem_t -= dt;
    }

    b_point_lights.buf[idx].pos = p;
    b_point_lights_dirs.buf[idx] = vec4(d, 1);
}
