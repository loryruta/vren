#version 460

#extension GL_GOOGLE_include_directive : require

#extension GL_EXT_debug_printf : enable

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

#include <common.glsl>
#include <debug.glsl>

layout(push_constant) uniform PushConstants
{
	uvec2 num_tiles;
	float camera_near;
	float camera_half_fov;
	mat4 camera_proj;
	mat4 camera_view;
} push_constants;

layout(set = 0, binding = 0) readonly buffer UniqueClusterKeyBuffer
{
	uint cluster_keys[];
};

layout(set = 0, binding = 1) readonly buffer ClusterKeyDispatchParams
{
	uvec4 cluster_key_dispatch_params;
};

layout(set = 0, binding = 2) writeonly buffer DebugDrawBuffer
{
    DebugDrawBufferVertex debug_draw_buffer[];
};

// TODO USE A COMMON FILE INSTEAD OF COPY-PASTING CLUSTERED SHADING FUNCTIONS

void decode_cluster_key(uint cluster_key, out uvec3 cluster_ijk, out vec3 cluster_normal)
{
	cluster_ijk = uvec3(
		cluster_key & 0xFF,
		(cluster_key >> 8) & 0xFF,
		(cluster_key >> 16) & 0x3FF
	);

	cluster_key >>= 26;

	cluster_normal = normalize(vec3(
		(cluster_key & 0x3) / 4.0 * 2.0 - 1.0,
		((cluster_key >> 2) & 0x3) / 4.0 * 2.0 - 1.0,
		((cluster_key >> 4) & 0x3) / 4.0 * 2.0 - 1.0
	));
}

void calc_cluster_aabb(
	uvec3 cluster_ijk,
	uvec2 num_tiles,
	float camera_near,
	float camera_half_fov,
	mat4 camera_proj,
	mat4 camera_view,
	out vec4 cluster_min,
	out vec4 cluster_max
)
{
	// Clip space tile min and tile max
	cluster_min.xy = cluster_ijk.xy / vec2(num_tiles);
	cluster_min.xy = vec2(cluster_min.x, 1.0 - cluster_min.y) * 2.0 - 1.0;
	cluster_min.z = 0.0;
	cluster_min.w = 1.0;

	cluster_max.xy = (cluster_ijk.xy + uvec2(1.0)) / vec2(num_tiles);
	cluster_max.xy = vec2(cluster_max.x, 1.0 - cluster_max.y) * 2.0 - 1.0;
	cluster_max.z = 0.0;
	cluster_max.w = 1.0;

	// Convert to view space
	mat4 inverse_proj = inverse(camera_proj);

	cluster_min = inverse_proj * cluster_min;
	cluster_min /= cluster_min.w;

	cluster_max = inverse_proj * cluster_max;
	cluster_max /= cluster_max.w;

	// Apply cluster's depth in view space
	float cluster_near = camera_near * pow(1 + (2 * tan(camera_half_fov)) / num_tiles.y, cluster_ijk.z); 
	float cluster_far = camera_near * pow(1 + (2 * tan(camera_half_fov)) / num_tiles.y, cluster_ijk.z + 1);
	
	vec3 d1 = normalize(cluster_min.xyz);
	vec3 d2 = normalize(cluster_max.xyz);

	cluster_min = vec4(cluster_near / d1.z * d1, 1);
	cluster_max = vec4(cluster_far / d2.z * d2, 1);
	
	// Convert to world space
	mat4 inverse_view = inverse(camera_view);

	cluster_min = inverse_view * cluster_min;
	cluster_max = inverse_view * cluster_max;

	vec4 tmp = cluster_min;
	cluster_min = min(cluster_min, cluster_max);
	cluster_max = max(tmp, cluster_max);
}

void main()
{
	if (gl_GlobalInvocationID.x < cluster_key_dispatch_params.w)
	{
		uint cluster_key = cluster_keys[gl_GlobalInvocationID.x];

		uvec3 cluster_ijk;
		vec3 cluster_normal;
		decode_cluster_key(cluster_key, cluster_ijk, cluster_normal);
		
		vec4 cluster_min, cluster_max;
		calc_cluster_aabb(
			cluster_ijk,
			push_constants.num_tiles,
			push_constants.camera_near,
			push_constants.camera_half_fov,
			push_constants.camera_proj,
			push_constants.camera_view,
			cluster_min,
			cluster_max
		);

		vec4 cluster_pos = (cluster_min + cluster_max) / 2.0;
		
		// Write draw buffer
		uint draw_buffer_offset = gl_GlobalInvocationID.x * (VREN_DEBUG_AABB_VERTICES_COUNT + VREN_DEBUG_LINE_VERTICES_COUNT);
	
        VREN_DEBUG_WRITE_AABB(debug_draw_buffer, draw_buffer_offset, cluster_min, cluster_max, 0xFF0000); // AABB

		vec3 line_from = cluster_pos.xyz;
		vec3 line_to = line_from + cluster_normal * 0.01;
		VREN_DEBUG_WRITE_LINE(debug_draw_buffer, draw_buffer_offset, line_from, line_to, 0xFFFFFF); // Normal
	}
}
