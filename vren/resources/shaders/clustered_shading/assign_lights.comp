#version 460

#extension GL_GOOGLE_include_directive : require

#extension GL_EXT_debug_printf : enable

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

#include <common.glsl>
#include <vren.glsl>
#include <clustered_shading.glsl>

#define VREN_MAX_STACK_DEPTH 5

#define VREN_BVH_LEAF_NODE 0xFFFFFFFFu
#define VREN_BVH_INVALID_NODE 0xFFFFFFFEu

layout(push_constant) uniform PushConstants
{
	uvec2 num_tiles;
	float camera_near;
	float camera_half_fov;
	mat4 camera_proj;
	mat4 camera_view;
	uint bvh_root_index;
	float _pad[3];
} push_constants;

struct BvhNode
{
	vec3 _min; uint next;
	vec3 _max; uint _pad;
};

layout(set = 0, binding = 0) readonly buffer UniqueClusterKeyBuffer
{
	uint cluster_keys[];
};

layout(set = 0, binding = 1) readonly buffer AllocationIndexBuffer
{
	uvec4 allocation_index;
};

layout(set = 0, binding = 2) readonly buffer BvhBuffer
{
	BvhNode bvh[];
};

layout(set = 0, binding = 3) readonly buffer LightIndexBuffer
{
	uvec2 light_indices[];
};

layout(set = 0, binding = 4) writeonly buffer AssignedLightBuffer
{
	uint assigned_lights[];
};

layout(set = 1, binding = 0) readonly buffer PointLightPositionBuffer
{
    vec4 point_light_positions[];
};

bool test_point_aabb(vec3 p, vec3 _min, vec3 _max)
{
	return p.x >= _min.x && p.y >= _min.y && p.z >= _min.z &&
		p.x <= _max.x && p.y <= _max.y && p.z <= _max.z;
}

bool test_aabb_aabb(vec3 _min_1, vec3 _max_1, vec3 _min_2, vec3 _max_2)
{
	return(
		_max_1.x > _min_2.x &&
		_min_1.x < _max_2.x &&
		_max_1.y > _min_2.y &&
		_min_1.y < _max_2.y &&
		_max_1.z > _min_2.z &&
		_min_1.z < _max_2.z
	);
}

void main()
{
	uint cluster_key_length = allocation_index.w;

	if (gl_GlobalInvocationID.x < cluster_key_length)
	{
		uint cluster_key = cluster_keys[gl_GlobalInvocationID.x];

		uvec3 cluster_ijk;
		uint cluster_normal_idx;
		clustered_shading_decode_cluster_key(cluster_key, cluster_ijk, cluster_normal_idx);

		vec4 cluster_min, cluster_max;
		clustered_shading_calc_cluster_aabb(
			cluster_ijk,
			push_constants.num_tiles,
			push_constants.camera_near,
			push_constants.camera_half_fov,
			push_constants.camera_proj,
			push_constants.camera_view,
			cluster_min,
			cluster_max
		);

		vec4 cluster_pos = (cluster_min + cluster_max) / 2.0;

		int assigned_light_alloc_idx = 0;

		BvhNode bvh_root_node = bvh[push_constants.bvh_root_index];
		if (
			//cluster_normal_idx < 0x3F && // The cluster has a valid normal
			test_aabb_aabb(cluster_min.xyz, cluster_max.xyz, bvh_root_node._min, bvh_root_node._max) // Light BVH affects the cluster
		)
		{
			uint stack[VREN_MAX_STACK_DEPTH];
			uint stack_ptr = 0;
			uint node_addr = push_constants.bvh_root_index - 32; // Start from first level after root

			bool keep_running = true;
			bool advance;

			while (keep_running)
			{
				BvhNode node = bvh[node_addr];

				advance = true;

				if (node.next != VREN_BVH_INVALID_NODE && test_aabb_aabb(cluster_min.xyz, cluster_max.xyz, node._min, node._max))
				{
					if (node.next == VREN_BVH_LEAF_NODE)
					{
						uint point_light_idx = light_indices[node_addr].y;
						
						vec3 point_light_pos = point_light_positions[point_light_idx].xyz;
						vec3 point_light_dir = normalize(point_light_pos.xyz - cluster_pos.xyz);
						
						// Assignment
						if (cluster_shading_is_cluster_affected(point_light_pos, cluster_min.xyz, cluster_max.xyz, cluster_normal_idx))
						{
							assigned_lights[gl_GlobalInvocationID.x * VREN_MAX_LIGHTS_PER_CLUSTER + assigned_light_alloc_idx] = point_light_idx;
							assigned_light_alloc_idx++;

							if (assigned_light_alloc_idx >= VREN_MAX_LIGHTS_PER_CLUSTER)
							{
								keep_running = false;
								break;
							}
						}
					}
					else
					{
						// Push
						stack[stack_ptr] = node_addr;
						stack_ptr++;
						node_addr = node.next;

						advance = false;
					}
				}

				// Advance
				if (advance)
				{
					node_addr++;

					while (node_addr % 32 == 0)
					{
						if (stack_ptr == 0)
						{
							keep_running = false;
							break;
						}

						// Pop
						stack_ptr--;
						node_addr = stack[stack_ptr];
						node_addr++;
					}
				}
			} // while
		}
	}
}
