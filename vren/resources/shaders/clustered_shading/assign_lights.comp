#version 460

#extension GL_GOOGLE_include_directive : require

#extension GL_EXT_debug_printf : enable

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

#include <common.glsl>

#define VREN_MAX_LIGHTS_PER_CLUSTER 8
#define VREN_MAX_STACK_DEPTH 5

#define VREN_BVH_LEAF_NODE 0xFFFFFFFFu
#define VREN_BVH_INVALID_NODE 0xFFFFFFFEu

layout(push_constant) uniform PushConstants
{
	uvec2 num_tiles;
	float camera_near;
	float camera_half_fov;
	mat4 camera_proj;
	mat4 camera_view;
	uint bvh_root_index;
	float _pad[3];
} push_constants;

struct BvhNode
{
	vec3 _min; uint next;
	vec3 _max; uint _pad;
};

layout(set = 0, binding = 0) readonly buffer UniqueClusterKeyBuffer
{
	uint cluster_keys[];
};

layout(set = 0, binding = 1) readonly buffer AllocationIndexBuffer
{
	uvec4 allocation_index;
};

layout(set = 0, binding = 2) readonly buffer BvhBuffer
{
	BvhNode bvh[];
};

layout(set = 0, binding = 3) readonly buffer LightIndexBuffer
{
	uvec2 light_indices[];
};

layout(set = 0, binding = 4) writeonly buffer AssignedLightBuffer
{
	uint assigned_lights[];
};

layout(set = 1, binding = 0) readonly buffer PointLightPositionBuffer
{
    vec4 point_light_positions[];
};

void decode_cluster_key(uint cluster_key, out uvec3 cluster_ijk, out vec3 cluster_normal)
{
	cluster_ijk = uvec3(
		cluster_key & 0xFF,
		(cluster_key >> 8) & 0xFF,
		(cluster_key >> 16) & 0x3FF
	);

	cluster_key >>= 26;

	cluster_normal = normalize(vec3(
		(cluster_key & 0x3) / 4.0 * 2.0 - 1.0,
		((cluster_key >> 2) & 0x3) / 4.0 * 2.0 - 1.0,
		((cluster_key >> 4) & 0x3) / 4.0 * 2.0 - 1.0
	));
}

void calc_cluster_aabb(
	uvec3 cluster_ijk,
	uvec2 num_tiles,
	float camera_near,
	float camera_half_fov,
	mat4 camera_proj,
	mat4 camera_view,
	out vec4 cluster_min,
	out vec4 cluster_max
)
{
	// Clip space tile min and tile max
	cluster_min = vec4(cluster_ijk.xy / vec2(num_tiles), 0.0, 1.0);
	cluster_min.xy = vec2(cluster_min.x, 1.0 - cluster_min.y) * 2.0 - 1.0;

	cluster_max = vec4((cluster_ijk.xy + uvec2(1.0)) / vec2(num_tiles), 0.0, 1.0);
	cluster_max.xy = vec2(cluster_max.x, 1.0 - cluster_max.y) * 2.0 - 1.0;

	// Convert to view space
	mat4 inverse_proj = inverse(camera_proj);

	cluster_min = inverse_proj * cluster_min;
	cluster_min /= cluster_min.w;

	cluster_max = inverse_proj * cluster_max;
	cluster_max /= cluster_max.w;

	// Apply cluster's depth in view space
	float cluster_near = camera_near * pow((1 + 2 * tan(camera_half_fov) / num_tiles.y), cluster_ijk.z); 
	float cluster_far = camera_near * pow((1 + 2 * tan(camera_half_fov) / num_tiles.y), cluster_ijk.z + 1);

	vec3 d1 = normalize(cluster_min.xyz);
	vec3 d2 = normalize(cluster_max.xyz);

	cluster_min = vec4(cluster_near / d1.z * d1, 1);
	cluster_max = vec4(cluster_far / d2.z * d2, 1);

	// Convert to world space
	mat4 inverse_view = inverse(camera_view);

	cluster_min = inverse_view * cluster_min;
	cluster_max = inverse_view * cluster_max;
}

bool test_point_aabb(vec3 p, vec3 _min, vec3 _max)
{
	return p.x >= _min.x && p.y >= _min.y && p.z >= _min.z &&
		p.x <= _max.x && p.y <= _max.y && p.z <= _max.z;
}

bool test_aabb_aabb(vec3 _min_1, vec3 _max_1, vec3 _min_2, vec3 _max_2)
{
	return(
		_max_1.x > _min_2.x &&
		_min_1.x < _max_2.x &&
		_max_1.y > _min_2.y &&
		_min_1.y < _max_2.y &&
		_max_1.z > _min_2.z &&
		_min_1.z < _max_2.z
	);
}

void main()
{
	uint cluster_key_length = allocation_index.w;

	if (gl_GlobalInvocationID.x < cluster_key_length)
	{
		uint cluster_key = cluster_keys[gl_GlobalInvocationID.x];

		uvec3 cluster_ijk;
		vec3 cluster_normal;
		decode_cluster_key(cluster_key, cluster_ijk, cluster_normal);

		vec4 cluster_min, cluster_max;
		calc_cluster_aabb(
			cluster_ijk,
			push_constants.num_tiles,
			push_constants.camera_near,
			push_constants.camera_half_fov,
			push_constants.camera_proj,
			push_constants.camera_view,
			cluster_min,
			cluster_max
		);

		vec4 cluster_pos = (cluster_min + cluster_max) / 2.0;

		int assigned_light_alloc_idx = 0;

		BvhNode bvh_root_node = bvh[push_constants.bvh_root_index];
		if (test_aabb_aabb(cluster_min.xyz, cluster_max.xyz, bvh_root_node._min, bvh_root_node._max)) // BVH root test
		{
			uint stack[VREN_MAX_STACK_DEPTH];
			uint stack_ptr = 0;
			uint node_addr = push_constants.bvh_root_index - 32; // Start from first level after root

			bool keep_running = true;
			bool advance;

			while (keep_running)
			{
				BvhNode node = bvh[node_addr];

				advance = true;

				if (node.next != VREN_BVH_INVALID_NODE && test_aabb_aabb(cluster_min.xyz, cluster_max.xyz, node._min, node._max))
				{
					if (node.next == VREN_BVH_LEAF_NODE)
					{
						uint point_light_idx = light_indices[node_addr].y;
						
						vec3 point_light_pos = point_light_positions[point_light_idx].xyz;
						vec3 point_light_dir = normalize(point_light_pos.xyz - cluster_pos.xyz);
						
						// Assignment
						if (dot(cluster_normal, point_light_dir) > 0)
						{
							assigned_lights[gl_GlobalInvocationID.x * VREN_MAX_LIGHTS_PER_CLUSTER + assigned_light_alloc_idx] = point_light_idx;
							assigned_light_alloc_idx++;

							if (assigned_light_alloc_idx >= VREN_MAX_LIGHTS_PER_CLUSTER)
							{
								keep_running = false;
								break;
							}
						}
					}
					else
					{
						// Push
						stack[stack_ptr] = node_addr;
						stack_ptr++;
						node_addr = node.next;

						advance = false;
					}
				}

				// Advance
				if (advance)
				{
					node_addr++;

					while (node_addr % 32 == 0)
					{
						if (stack_ptr == 0)
						{
							keep_running = false;
							break;
						}

						// Pop
						stack_ptr--;
						node_addr = stack[stack_ptr];
						node_addr++;
					}
				}
			} // while
		}
	}
}
