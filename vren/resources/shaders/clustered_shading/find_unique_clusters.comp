#version 460

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

#include <common.glsl>
#include <primitives.glsl>

#define VREN_CLUSTER_KEY_BIT_COUNT 10

layout(push_constant) uniform PushConstants
{
	float camera_near;
	float camera_half_fov_y;
};

// gBuffer
layout(set = 0, binding = 0) uniform sampler2D gbuffer_positions;
layout(set = 0, binding = 1) uniform sampler2D gbuffer_normals;
layout(set = 0, binding = 2) uniform sampler2D gbuffer_texcoords;
layout(set = 0, binding = 3) uniform usampler2D gbuffer_material_indices;

layout(set = 1, binding = 0) writeonly buffer ClusterKeyBuffer
{
	uint cluster_keys[];
};

layout(set = 1, binding = 1) buffer AllocationIndexBuffer
{
	uvec4 allocation_index; // w is the allocation index, while xyz the indirect dispatch parameters
};

layout(set = 1, binding = 2, r32ui) uniform uimage2D u_cluster_references;

// 8k of SMEM
shared uint s_cluster_key_occurrences[1 << VREN_CLUSTER_KEY_BIT_COUNT /* 1024 */];
shared uint s_unique_cluster_keys[1024];
shared uint s_allocation_index;

void main()
{
	if (gl_LocalInvocationIndex < (1 << VREN_CLUSTER_KEY_BIT_COUNT))
	{
		s_cluster_key_occurrences[gl_LocalInvocationIndex] = 0;
	}

	barrier();

	vec2 sample_texcoord = vec2(gl_GlobalInvocationID.xy) / textureSize(gbuffer_positions, 0);
	vec3 sample_position = texture(gbuffer_positions, sample_texcoord).rgb;
	
	uint i = gl_WorkGroupID.x;
	uint j = gl_WorkGroupID.y;

	uint Sy = gl_NumWorkGroups.y;
	uint k = uint(floor(log(sample_position.z / camera_near) / log(1 + (2 * tan(camera_half_fov_y)) / Sy)));

	s_cluster_key_occurrences[k] = 1;

	barrier();
	
	uint unique_key_count = s_cluster_key_occurrences[(1 << VREN_CLUSTER_KEY_BIT_COUNT) - 1];

	VREN_WORKGROUP_EXCLUSIVE_SCAN(s_cluster_key_occurrences, 1 << VREN_CLUSTER_KEY_BIT_COUNT, 0, 1);

	barrier();

	unique_key_count += s_cluster_key_occurrences[(1 << VREN_CLUSTER_KEY_BIT_COUNT) - 1];

	if (gl_LocalInvocationIndex == 0)
	{
		s_allocation_index = atomicAdd(allocation_index.w, unique_key_count);

		if (uint(s_allocation_index / 1024) != uint((s_allocation_index + unique_key_count) / 1024))
		{
			atomicAdd(allocation_index.x, 1);
		}
	}

	s_unique_cluster_keys[s_cluster_key_occurrences[k]] = k;

	barrier();

	if (gl_LocalInvocationIndex < unique_key_count)
	{
		uint cluster_key = 0;
		cluster_key |= i & 0xFF;
		cluster_key |= (j & 0xFF) << 8;
		cluster_key |= (s_unique_cluster_keys[gl_LocalInvocationIndex] & 0x3FF) << 16;

		uint cluster_key_idx = s_allocation_index + gl_LocalInvocationIndex;
		if (cluster_key_idx < cluster_keys.length())
		{
			cluster_keys[cluster_key_idx] = cluster_key;
		}

		imageStore(u_cluster_references, ivec2(gl_GlobalInvocationID.xy), uvec4(cluster_key_idx));
	}
}
