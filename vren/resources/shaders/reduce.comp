#version 460

#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#define UINT32_MAX 0xffffffffu

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

#define NUM_ITERS 16

layout(push_constant) uniform PushConstants
{
	uint offset;
	uint stride;
};

layout(set = 0, binding = 0) buffer Buffer
{
	uint data[]; // Length must be a power of 2
};

uint previous_power_of_2(uint v)
{
	 v |= v >> 1;
     v |= v >> 2;
     v |= v >> 4;
     v |= v >> 8;
     v |= v >> 16;
     return v - (v >> 1);
}

void main()
{
	uint thread_values[NUM_ITERS];

	// Read values from global memory
	for (uint i = 0; i < NUM_ITERS; i++)
	{
		thread_values[i] = data[offset + (gl_GlobalInvocationID.x * NUM_ITERS + i) * stride];
	}

	// Perform a invocation-wide reduction
	for (uint level = 0; level < log2(NUM_ITERS); level++)
	{
        for (uint item_idx = 0; item_idx < (NUM_ITERS >> (level + 1)); item_idx++)
        {
            uint a_idx = (1 << level) - 1 + (item_idx << (level + 1));
            uint b_idx = (1 << level) - 1 + (item_idx << (level + 1)) + (1 << level);

            thread_values[b_idx] = thread_values[a_idx] + thread_values[b_idx];
        }
	}

	// Perform a subgroup-wide reduction
	uint thread_value = thread_values[NUM_ITERS - 1];

	for (uint level = 0; level < log2(32); level++)
	{
		uint thread_idx = gl_LocalInvocationID.x;

		uint level_mask = (1 << level) - 1; 
		uint active_threads = subgroupBallot((thread_idx & level_mask) == level_mask).x;

		uint sum_mask = (level + 1) < 5 ? (1 << (1 << (level + 1))) - 1 : UINT32_MAX; // level + 1 >= 5 then 2^(2^(level + 1)) overflows (2^32 overflows)

		uint shift_by = 1 << (level + 1);
		for (; sum_mask != 0; sum_mask = shift_by < 32 ? sum_mask << shift_by : 0) // Left shifting by 32 or higher is UB
		{
			uint sum_threads = active_threads & sum_mask;

			if (subgroupInverseBallot(uvec4(sum_threads)))
			{
				uint sum = subgroupAdd(thread_value);

				uint last_thread = previous_power_of_2(sum_threads);
				if (subgroupInverseBallot(uvec4(last_thread)))
				{
					thread_value = sum;
				}
			}
		}
	}

	thread_values[NUM_ITERS - 1] = thread_value;

	// Write values back to global memory
	for (uint i = 0; i < NUM_ITERS; i++)
	{
		data[offset + (gl_GlobalInvocationID.x * NUM_ITERS + i) * stride] = thread_values[i];
	}
}
