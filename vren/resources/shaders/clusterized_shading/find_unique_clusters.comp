#version 460

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

#include <primitives.glsl>

#define VREN_DEPTH_BITS 10
#define VREN_DEPTH_CARDINALITY (1 << VREN_DEPTH_BITS)
#define VREN_DEPTH_NUM_ITEMS (VREN_DEPTH_CARDINALITY / (32 * 32))

// gBuffer
layout(set = 0, binding = 0, rgba32f) uniform image2D gbuffer_positions;
layout(set = 0, binding = 1, rgba16f) uniform image2D gbuffer_normals;
layout(set = 0, binding = 2, rg16f) uniform image2D gbuffer_texcoords;
layout(set = 0, binding = 3, r16ui) uniform image2D gbuffer_material_indices;

layout(set = 0, binding = 0) writeonly buffer ClusterKeyBuffer
{
	uint cluster_keys[];
};

layout(set = 0, binding = 0) writeonly buffer ClusterSampleReferenceBuffer
{
	uint16_t cluster_sample_references[];
};

shared uint s_depth_count[VREN_DEPTH_CARDINALITY]; // Could be uint16_t

void main()
{
	uvec3 cluster_pos;
	cluster_pos.x = gl_WorkGroupID.x;
	cluster_pos.y = gl_WorkGroupID.y;
	cluster_pos.z = 0; // TODO
	
	// Init
	for (uint i = 0; i < VREN_DEPTH_NUM_ITEMS; i++)
	{
		s_depth_count[gl_LocalInvocationIndex * VREN_DEPTH_NUM_ITEMS + i] = 0;
	}

	// Set just 1 occurrence for the value k, this will also compact
	s_depth_count[cluster_pos.z] = 1;

	barrier();

	// Exclusive-scan
	_VRN_WORKGROUP_REDUCE(s_depth_count, 1 << _VREN_DEPTH_BITS, 0, 1);

	uint count = s_depth_count[(1 << _VREN_DEPTH_BITS) - 1];

	s_depth_count[(1 << _VREN_DEPTH_BITS) - 1] = 0;
	barrier();

	_VREN_WORKGROUP_EXCLUSIVE_SCAN(s_depth_count, 1 << _VREN_DEPTH_BITS, 0, 1);

	//barrier();

	// Store a unique list for this cluster
	uint base_offset = gl_WorkGroupID.x * (32 * 32) + gl_WorkGroupID.y;
	cluster_keys[base_offset] = count; // First element is the count of elements within the list

	uint cluster_key = i | (j << 8) | (k << 16);
	cluster_keys[base_offset + 1 + s_depth_count[k]] = cluster_key;

	// TODO back-ref
}
