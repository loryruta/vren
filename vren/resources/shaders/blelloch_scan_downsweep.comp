#version 460

#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_shuffle : require

#extension GL_EXT_debug_printf : enable

#define UINT32_MAX 0xffffffffu

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

#ifndef NUM_ITERS
#	error NUM_ITERS not defined
#endif

// Requirements:
// - MAIN_DOWNSWEEP defined to "main" or MAIN_SUBGROUP_DOWNSWEEP defined to "main"

layout(push_constant) uniform PushConstants
{
	uint level;
	uint clear_last; // 0 if shouldn't clear last value, otherwise 1
	uint block_length;
};

layout(set = 0, binding = 0) buffer Buffer
{
	uint data[];
};

#ifdef MAIN_DOWNSWEEP
void main()
{
	uint block_offset = gl_WorkGroupID.y * block_length;
	
    uint offset = (1u << level) - 1;
    uint stride = 1u << level;

	for (uint i = 0; i < NUM_ITERS; i++)
	{
		uint a_idx = offset + (gl_GlobalInvocationID.x * NUM_ITERS + i) * stride * 2;
		uint b_idx = offset + (gl_GlobalInvocationID.x * NUM_ITERS + i) * stride * 2 + stride;

		if (a_idx < block_length)
		{
			uint b = clear_last != 0 && b_idx == block_length - 1 ? 0 : data[block_offset + b_idx];

			data[block_offset + b_idx] = data[block_offset + a_idx] + b;
			data[block_offset + a_idx] = b;
		}
	}
}
#endif

#ifdef MAIN_SUBGROUP_DOWNSWEEP
void main()
{
	uint block_offset = gl_WorkGroupID.y * block_length;

	uint thread_values[NUM_ITERS];

	for (uint i = 0; i < NUM_ITERS; i++)
	{
		uint data_idx = gl_GlobalInvocationID.x * NUM_ITERS + i; // Array is tightly packed here: offset and stride ignored
		uint val = clear_last != 0 && data_idx == (block_length - 1) ? 0 : data[block_offset + data_idx];
		thread_values[i] = val;
	}
	
	uint thread_value = thread_values[NUM_ITERS - 1];

	for (int level = int(log2(32)) - 1; level >= 0; level--)
	{
		uint thread_idx = gl_SubgroupInvocationID.x;

		uint level_mask = (1 << level) - 1; 
		uint active_threads = subgroupBallot((thread_idx & level_mask) == level_mask).x;

		uint op_mask = (level + 1) < 5 ? (1 << (1 << (level + 1))) - 1 : UINT32_MAX; // level + 1 >= 5 then 2^(2^(level + 1)) overflows (2^32 overflows)

		uint shift_by = 1 << (level + 1);
		for (; op_mask != 0; op_mask = shift_by < 32 ? op_mask << shift_by : 0) // Left shifting by 32 or higher is UB
		{
			uint op_threads = active_threads & op_mask;

			if (subgroupInverseBallot(uvec4(op_threads)))
			{
				uint sum = subgroupAdd(thread_value);

				uint right_thread_idx = findMSB(op_threads);
				uint right_thread_mask = 1 << findMSB(op_threads);
				uint right_value = subgroupShuffle(thread_value, right_thread_idx);

				if (subgroupInverseBallot(uvec4(right_thread_mask)))
				{
					thread_value = sum;
				}

				if (subgroupInverseBallot(uvec4(1 << findLSB(op_threads))))
				{
					thread_value = right_value;
				}
			}
		}
	}

	thread_values[NUM_ITERS - 1] = thread_value;

	for (int level = int(log2(NUM_ITERS)) - 1; level >= 0; level--)
	{
		for (uint item_idx = 0; item_idx < (NUM_ITERS >> (level + 1)); item_idx++)
        {
            uint a_idx = (1 << level) - 1 + (item_idx << (level + 1));
            uint b_idx = (1 << level) - 1 + (item_idx << (level + 1)) + (1 << level);

			uint tmp = thread_values[b_idx];
            thread_values[b_idx] = thread_values[a_idx] + tmp;
			thread_values[a_idx] = tmp;
        }
	}

	for (uint i = 0; i < NUM_ITERS; i++)
	{
		uint data_idx = gl_GlobalInvocationID.x * NUM_ITERS + i;
		data[block_offset + data_idx] = thread_values[i];
	}
}
#endif
